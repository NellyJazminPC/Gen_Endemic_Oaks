# Luego, puedes usar chordDiagram con el parámetro gap.degree especificado
chordDiagram(contingency_table, gap.degree = gap_degree)
# Obtener el número de sectores en el diagrama
num_sectores <- nrow(contingency_table)
# Crear un vector gap.degree con la misma longitud que el número de sectores
gap_degree <- rep(5, num_sectores)  # Establecer un espacio de 5 grados entre las cuerdas
# Luego, puedes usar chordDiagram con el parámetro gap.degree especificado
chordDiagram(contingency_table, gap.degree = gap_degree)
split_data_clean
View(split_data_categories)
View(split_data_categories)
View(split_data_clean)
library(networkD3)
# Paso 1: Prepara los datos
links <- split_data_clean %>%
select(Subgenus, Quercus_section, `IUCN Red List Category`, WoS_categories) %>%
drop_na() %>%
mutate_all(as.character()) %>%
mutate(ID = row_number()) %>%
pivot_longer(cols = -ID, names_to = "Source", values_to = "Target") %>%
mutate(Source = factor(Source, levels = c("Subgenus", "Quercus_section", "IUCN Red List Category", "WoS_categories")))
# Paso 2: Crea el diagrama de Sankey
sankeyNetwork(Links = links, Source = "Source", Target = "Target", Value = "ID",
NodeID = c(levels(links$Source), levels(links$Target)))
# Obtener los nodos únicos
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
# Crear el diagrama de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "Source", Target = "Target", Value = "ID",
NodeID = nodes$name)
# Paso 2: Crea el diagrama de Sankey
sankeyNetwork(Links = links, Source = "Source", Target = "Target", Value = "ID",
NodeID = c(levels(links$Source), levels(links$Target)))
# Obtener los nodos únicos
nodes
View(df_filtered_microend)
# Obtener los nodos únicos
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
nodes
links
# Paso 1: Prepara los datos
links <- split_data_clean %>%
select(Subgenus, Quercus_section, `IUCN Red List Category`, WoS_categories) %>%
drop_na() %>%
mutate_all(as.character()) %>%
mutate(ID = row_number()) %>%
pivot_longer(cols = -ID, names_to = "Source", values_to = "Target") %>%
mutate(Source = factor(Source, levels = c("Subgenus", "Quercus_section", "IUCN Red List Category", "WoS_categories")))
# Paso 2: Crea el diagrama de Sankey
sankeyNetwork(Links = links, Source = "Source", Target = "Target", Value = "ID",
NodeID = c(levels(links$Source), levels(links$Target)))
library(networkD3)
library(dplyr)
library(networkD3)
# Paso 1: Prepara los datos
links <- split_data_clean %>%
select(Subgenus, Quercus_section, `IUCN Red List Category`, WoS_categories) %>%
drop_na() %>%
mutate_all(as.character()) %>%
mutate(ID = row_number()) %>%
pivot_longer(cols = -ID, names_to = "Source", values_to = "Target") %>%
mutate(Source = factor(Source, levels = c("Subgenus", "Quercus_section", "IUCN Red List Category", "WoS_categories")))
# Obtener los nodos únicos
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
# Crear el diagrama de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "Source", Target = "Target", Value = "ID",
NodeID = nodes$name)
sankeyNetwork(Links = links, Nodes = nodes, Source = "Source", Target = "Target", Value = "ID",
NodeID = "name")
# Datos de ejemplo
links <- data.frame(
Source = c("A", "A", "B", "B", "C"),
Target = c("X", "Y", "X", "Z", "Y"),
Value = c(10, 20, 30, 40, 50)
)
# Obtener nodos únicos
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
# Crear el gráfico de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "Source", Target = "Target", Value = "Value",
NodeID = "name")
library(networkD3)
# Datos de ejemplo
links <- data.frame(
Source = c("A", "A", "B", "B", "C"),
Target = c("X", "Y", "X", "Z", "Y"),
Value = c(10, 20, 30, 40, 50)
)
# Obtener nodos únicos
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
# Crear el gráfico de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "Source", Target = "Target", Value = "Value",
NodeID = "name")
# Instalar y cargar el paquete
#install.packages("networkD3")
library(networkD3)
# Definir los nodos
nodes <- data.frame(
name = c("A", "B", "C", "D", "E")
)
# Definir los enlaces (links)
links <- data.frame(
source = c(0, 1, 1, 2, 2, 3),
target = c(1, 2, 3, 3, 4, 4),
value = c(10, 15, 5, 10, 5, 20)
)
# Crear el diagrama de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "source", Target = "target", Value = "value", NodeID = "name", units = "TWh", fontSize = 12, nodeWidth = 30)
library(networkD3)
# Datos de ejemplo
links <- data.frame(
Source = c("A", "A", "B", "B"),
Target = c("X", "Y", "X", "Z"),
Value = c(6, 8, 10, 12)
)
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
# Crear el gráfico de Sankey
sankey <- sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "Source",
Target = "Target",
Value = "Value",
NodeID = "name"
)
sankey
library(networkD3)
library(dplyr)
library(tidyr)
# Datos de ejemplo
links <- data.frame(
Source = c("A", "A", "B", "B"),
Target = c("X", "Y", "X", "Z"),
Value = c(6, 8, 10, 12)
)
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
# Crear el gráfico de Sankey
sankey <- sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "Source",
Target = "Target",
Value = "Value",
NodeID = "name"
)
sankey
View(sankey)
sankey[["jsHooks"]]
# Definir los nodos
nodes <- data.frame(
name = c("A", "B", "C", "D", "E")
)
# Definir los enlaces (links)
links <- data.frame(
source = c(0, 1, 1, 2, 2, 3),
target = c(1, 2, 3, 3, 4, 4),
value = c(10, 15, 5, 10, 5, 20)
)
# Crear el diagrama de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "source", Target = "target", Value = "value", NodeID = "name", units = "TWh", fontSize = 12, nodeWidth = 30)
# Datos de ejemplo
links <- data.frame(
Source = c("A", "A", "B", "B"),
Target = c("X", "Y", "X", "Z"),
Value = c(6, 8, 10, 12)
)
links
links <- data.frame(
source = c(0, 1, 1, 2, 2, 3),
target = c(1, 2, 3, 3, 4, 4),
value = c(10, 15, 5, 10, 5, 20)
links
links <- data.frame(
source = c(0, 1, 1, 2, 2, 3),
target = c(1, 2, 3, 3, 4, 4),
value = c(10, 15, 5, 10, 5, 20)
)
links
# Datos de ejemplo
links <- data.frame(
Source = c("A", "A", "B", "B"),
Target = c("X", "Y", "X", "Z"),
Value = c(6, 8, 10, 12)
)
nodes <- data.frame(name = unique(c(links$Source, links$Target)))
nodes
sankeyNetwork(
Links = links,
Nodes = nodes,
Source = "Source",
Target = "Target",
Value = "Value",
NodeID = "name"
)
# Crear el diagrama de Sankey
sankeyNetwork(Links = links, Nodes = nodes, Source = "source", Target = "target", Value = "value", NodeID = "name", units = "TWh", fontSize = 12, nodeWidth = 30)
# Contar la frecuencia de cada combinación de especie de Quercus y categoría de WoS
sankey_data <- table(split_data_clean$Quercus_species, split_data_clean$WoS_categories)
# Convertir los datos a un formato de matriz
sankey_matrix <- as.matrix(sankey_data)
# Crear el diagrama de Sankey
sankey <- sankeyNetwork(Links = sankey_matrix,
Source = colnames(sankey_matrix),
Target = rownames(sankey_matrix),
Value = sankey_matrix,
NodeID = c(rownames(sankey_matrix), colnames(sankey_matrix)),
units = "Frequency")
gc()
gc()
library(rgbif)
library(rgbif)
library(dplyr)
library(leaflet)
library(sf)
library(sp)
library(tmaptools)
library(tmap)
library(readxl)
library(writexl)
# Leer el archivo Excel
file_path <- "../data/Base_datos_encinos_endémicos.xlsx"
Base_datos_encinos_end <- read_excel(file_path, sheet = "Oaks_RedList")
library(readxl)
library(writexl)
# Leer el archivo Excel
file_path <- "../data/Base_datos_encinos_endémicos.xlsx"
Base_datos_encinos_end <- read_excel(file_path, sheet = "Oaks_RedList")
# Leer el archivo Excel
file_path <- "../data/Base_datos_encinos_endémicos.xlsx"
Base_datos_encinos_end <- read_excel(file_path, sheet = "Oaks_RedList")
# Mostrar el data frame leído
print("Data frame leído:")
print(Base_datos_encinos_end)
# Filtrar las filas con los valores "Y" en la columna "Backs_Ashley_2021"
Base_Backs_Ashley <- Base_datos_encinos_end %>%
filter(Backs_Ashley_2021 %in% "Y")
nombre_cientifico <- tolower(Base_Backs_Ashley$`Scientific Name`)
# Mostrar el vector extraído
print("Nombres científicos de las 124 especies:")#81 para esta primera prueba
print(nombre_cientifico)
# Lista de especies
species_list <- nombre_cientifico
# Función para obtener el key de la especie
get_species_key <- function(species_name) {
backbone <- name_backbone(name = species_name)
return(backbone$speciesKey)
}
# Función para descargar datos de presencia de una especie
download_species_data <- function(species_key) {
# Descargar los datos de presencia
occurrences <- occ_search(taxonKey = species_key, limit = 500)
return(occurrences$data)
}
# Obtener los keys de las especies
species_keys <- sapply(species_list, get_species_key)
print(species_keys)
# Descargar datos de todas las especies en la lista
species_data <- lapply(species_keys, download_species_data)
# Encontrar todas las columnas presentes en los data frames descargados
all_columns <- unique(unlist(lapply(species_data, colnames)))
# Función para asegurar que un data frame tenga todas las columnas necesarias
standardize_columns <- function(df, all_columns) {
for (col in all_columns) {
if (!col %in% colnames(df)) {
df[[col]] <- NA
}
}
return(df[, all_columns])
}
# Estandarizar columnas en todos los data frames
species_data <- lapply(species_data, standardize_columns, all_columns)
library(dplyr)
library(sf)
library(sp)
library(tmaptools)
library(tmap)
library(magrittr)
library(readxl)
library(stringr)
library(writexl)
#nombre_cientifico <- tolower(Base_Backs_Ashley$`Scientific Name`)
nombre_cientifico <- tolower(Base_datos_encinos_end$`Scientific Name`)
# Mostrar el vector extraído
print("Nombres científicos de las 124 especies:")#430 para esta primera prueba
print(nombre_cientifico)
# Lista de especies
species_list <- nombre_cientifico
# Función para obtener el key de la especie
get_species_key <- function(species_name) {
backbone <- name_backbone(name = species_name)
return(backbone$speciesKey)
}
# Función para descargar datos de presencia de una especie
download_species_data <- function(species_key) {
# Descargar los datos de presencia
occurrences <- occ_search(taxonKey = species_key, limit = 3000)
return(occurrences$data)
}
# Función para obtener el key de la especie
get_species_key <- function(species_name) {
backbone <- name_backbone(name = species_name)
return(backbone$speciesKey)
}
# Función para descargar datos de presencia de una especie
download_species_data <- function(species_key) {
# Descargar los datos de presencia
occurrences <- occ_search(taxonKey = species_key, limit = 3000)
return(occurrences$data)
}
# Obtener los keys de las especies
species_keys <- sapply(species_list, get_species_key)
# Descargar datos de todas las especies en la lista
species_data <- lapply(species_keys, download_species_data)
# Encontrar todas las columnas presentes en los data frames descargados
all_columns <- unique(unlist(lapply(species_data, colnames)))
# Función para asegurar que un data frame tenga todas las columnas necesarias
standardize_columns <- function(df, all_columns) {
if (is.data.frame(df)) {
for (col in all_columns) {
if (!col %in% colnames(df)) {
df[[col]] <- NA
}
}
return(df[, all_columns])
} else {
# Si df no es un data frame, devuelve un data frame vacío con las columnas esperadas
return(data.frame(matrix(ncol = length(all_columns), nrow = 0, dimnames = list(NULL, all_columns))))
}
}
# Estandarizar columnas en todos los data frames
species_data <- lapply(species_data, standardize_columns, all_columns)
# Combinar todos los datos en un solo data frame
combined_data <- do.call(rbind, species_data)
# Filtrar columnas necesarias para el mapa
map_data <- combined_data %>% select(species, decimalLongitude, decimalLatitude) %>%
filter(!is.na(decimalLongitude) & !is.na(decimalLatitude))
# Convertir los datos a un objeto sf
sf_points <- st_as_sf(map_data, coords = c("decimalLongitude", "decimalLatitude"), crs = 4326)
# Generar hexágonos
hex_grid <- st_make_grid(sf_points, cellsize = 1, square = FALSE) # Ajusta cellsize según sea necesario
hex_grid <- st_as_sf(hex_grid)
hex_grid$id <- 1:nrow(hex_grid)
# Intersección de puntos con hexágonos
hex_intersection <- st_intersects(hex_grid, sf_points)
# Contar el número de puntos por especie en cada hexágono
hex_species_count <- sapply(hex_intersection, function(x) {
if (length(x) == 0) {
return(NULL)
} else {
return(table(map_data$species[x]))
}
})
# Crear un data frame con los resultados
hex_species_df <- do.call(rbind, lapply(1:length(hex_species_count), function(i) {
if (is.null(hex_species_count[[i]]) || length(hex_species_count[[i]]) == 0) {
return(data.frame(id = i, species = NA, count = 0))
} else {
return(data.frame(id = i, species = names(hex_species_count[[i]]), count = as.vector(hex_species_count[[i]])))
}
}))
# Unir los datos de especies a los hexágonos
hex_grid <- merge(hex_grid, hex_species_df, by = "id")
# Crear el resumen del número de hexágonos por especie
hex_summary <- hex_species_df %>%
filter(!is.na(species)) %>%
group_by(species) %>%
summarise(hex_count = n_distinct(id))
print(hex_summary)
class(hex_summary)
# Verificar que los datos se cargaron correctamente
print(hex_summary)
# Filtrar los datos para solo Quercus
hex_summary_filtered <- hex_summary %>%
filter(str_detect(species, "^Quercus\\s+\\w+"))
print(hex_summary_filtered)
# Crear el mapa
tmap_mode("view")
tm_shape(hex_grid) +
tm_polygons("area_km2", title = "Hexagon Area (km^2)", alpha = 0.5) +
tm_shape(sf_points) +
tm_dots(col = "species", palette = "Set1", title = "Species Occurrences", size = 0.5) +
tm_layout(legend.outside = TRUE)
tm_shape(hex_grid) +
tm_polygons("area_km2", fill_alpha = 0.5, fill.legend = tm_legend(title = "Hexagon Area (km^2)")) +
tm_shape(sf_points) +
tm_dots(col = "species", palette = "Set1", fill = "species", size = 0.5, border.col = "black", title = "Species Occurrences") +
tm_layout(legend.outside = TRUE)
# Crear el mapa
tmap_mode("view")
tm_shape(hex_summary_filtered) +
tm_polygons("count", title = "Species Count", alpha = 0.5) +
tm_shape(sf_points) +
tm_dots(col = "species", palette = "Set1", title = "Species Occurrences", size = 0.5) +
tm_layout(legend.outside = TRUE)
# Crear el mapa
tmap_mode("view")
tm_shape(hex_grid) +
tm_polygons("area_km2", fill_alpha = 0.5, fill.legend = tm_legend(title = "Hexagon Area (km^2)")) +
tm_shape(sf_points) +
tm_dots(col = "species", palette = "Set1", fill = "species", size = 0.5, border.col = "black", title = "Species Occurrences") +
tm_layout(legend.outside = TRUE)
tmap_mode("view")
tmap_mode("view")
tm_shape(hex_grid) +
tm_polygons("area_km2", fill_alpha = 0.5, fill.legend = tm_legend(title = "Hexagon Area (km^2)")) +
tm_shape(sf_points) +
tm_dots(fill = "species", fill.scale = tm_scale(values = "Set1"), size = 0.5, col = "black", title = "Species Occurrences") +
tm_layout(legend.outside = TRUE)
# Filtrar los datos para solo Quercus
hex_summary_filtered <- hex_summary %>%
filter(str_detect(species, "^Quercus\\s+\\w+"))
print(hex_summary_filtered)
tmap_mode("view")
tm_shape(hex_grid) +
tm_polygons("area_km2", fill_alpha = 0.5, fill.legend = tm_legend(title = "Hexagon Area (km^2)")) +
tm_shape(sf_points) +
tm_dots(fill = "species", fill.scale = tm_scale(values = "Set1"), size = 0.5, col = "black", title = "Species Occurrences") +
tm_layout(legend.outside = TRUE)
library(tmap)
library(tmaptools)
library(dplyr)
library(stringr)
# Filtrar los datos para solo Quercus
hex_summary_filtered <- hex_summary %>%
filter(str_detect(species, "^Quercus\\s+\\w+"))
print(hex_summary_filtered)
tmap_mode("view")
tm_shape(hex_grid) +
tm_polygons(col = "area_km2", alpha = 0.5, title = "Hexagon Area (km^2)") +
tm_shape(sf_points) +
tm_dots(col = "species", palette = "Set1", size = 0.5, title = "Species Occurrences", border.col = "black") +
tm_layout(legend.outside = TRUE)
# Filtrar los datos para solo Quercus
hex_summary_filtered <- hex_summary %>%
filter(str_detect(species, "^Quercus\\s+\\w+"))
print(hex_summary_filtered)
tmap_mode("view")
tm_shape(hex_grid) +
tm_polygons(fill = "area_km2", fill_alpha = 0.5, fill.legend = tm_legend(title = "Hexagon Area (km^2)")) +
tm_shape(sf_points) +
tm_dots(fill = "species", fill.scale = tm_scale(values = "Set1"), size = 0.5, col = "black", title = "Species Occurrences") +
tm_layout(legend.outside = TRUE)
hex_grid
# Crear el mapa
tmap_mode("view")
tm_shape(hex_grid) +
tm_polygons(fill = "count", fill_alpha = 0.5, fill.legend = tm_legend(title = "Hexagon Area (km^2)")) +
tm_shape(sf_points) +
tm_dots(fill = "species", fill.scale = tm_scale(values = "Set1"), size = 0.5, col = "black", title = "Species Occurrences") +
tm_layout(legend.outside = TRUE)
mapa <- tm_shape(hex_grid) +
tm_polygons(fill = "count", fill_alpha = 0.5, fill.legend = tm_legend(title = "Hexagon Area (km^2)")) +
tm_shape(sf_points) +
tm_dots(fill = "species", fill.scale = tm_scale(values = "Set1"), size = 0.5, col = "black", title = "Species Occurrences") +
tm_layout(legend.outside = TRUE)
# Guardar el mapa como un archivo HTML
tmap_save(mapa, "../plots/mapa_hex.html")
library(rgbif)
library(dplyr)
library(leaflet)
library(sf)
library(sp)
library(tmaptools)
library(tmap)
library(readxl)
install.packages("readxl")
library(readxl)
library(writexl)
# Leer el archivo Excel
file_path <- "../data/Base_datos_encinos_endémicos.xlsx"
Base_datos_encinos_end <- read_excel(file_path, sheet = "Oaks_RedList")
# Mostrar el data frame leído
print("Data frame leído:")
print(Base_datos_encinos_end)
# Filtrar las filas con los valores "Y" en la columna "Backs_Ashley_2021"
Base_Backs_Ashley <- Base_datos_encinos_end %>%
filter(Backs_Ashley_2021 %in% "Y")
nombre_cientifico <- tolower(Base_Backs_Ashley$`Scientific Name`)
# Mostrar el vector extraído
print("Nombres científicos de las 124 especies:")#81 para esta primera prueba
print(nombre_cientifico)
# Lista de especies
species_list <- nombre_cientifico
# Función para obtener el key de la especie
get_species_key <- function(species_name) {
backbone <- name_backbone(name = species_name)
return(backbone$speciesKey)
}
# Función para descargar datos de presencia de una especie
download_species_data <- function(species_key) {
# Descargar los datos de presencia
occurrences <- occ_search(taxonKey = species_key, limit = 500)
return(occurrences$data)
}
# Obtener los keys de las especies
species_keys <- sapply(species_list, get_species_key)
print(species_keys)
# Descargar datos de todas las especies en la lista
species_data <- lapply(species_keys, download_species_data)
# Encontrar todas las columnas presentes en los data frames descargados
all_columns <- unique(unlist(lapply(species_data, colnames)))
# Función para asegurar que un data frame tenga todas las columnas necesarias
standardize_columns <- function(df, all_columns) {
for (col in all_columns) {
if (!col %in% colnames(df)) {
df[[col]] <- NA
}
}
return(df[, all_columns])
}
# Estandarizar columnas en todos los data frames
species_data <- lapply(species_data, standardize_columns, all_columns)
# Combinar todos los datos en un solo data frame
combined_data <- do.call(rbind, species_data)
